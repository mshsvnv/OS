/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

 #define _GNU_SOURCE
#include <stdio.h>
#include <pthread.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>
#include <stdbool.h>
#include <sys/time.h>
#include <time.h>
#include <signal.h>

#include "bakery.h"

struct thread_arg_t
{
	int id;
	int number;
	int letter;
};

uint64_t starts[32] = {0};
int choosing[32] = {0};
int numbers[32] = {0};
int cur_id = 0;
char cur_letter = 'a';

pthread_t threads[32];
struct thread_arg_t threads_results[32] = {0};

static uint64_t now_nano()
{
    struct timespec t;
    if (clock_gettime(CLOCK_REALTIME, &t))
        return -1;
    return t.tv_sec * 1000000000LL + t.tv_nsec;
}

void* get_service(void *arg) {
	struct thread_arg_t *targ = arg;
    int i = targ->id;
	uint64_t start, end;
	uint64_t start_time = now_nano();

	for (int j = 0; j < 32; j++)
	{
		start = now_nano();
		while (choosing[j]);
		while ((numbers[j] > 0) && (numbers[j] < numbers[i] || (numbers[j] == numbers[i] && j < i)))
		{
			end = now_nano();
        	if (end - start > 1e8)
            {
				j++;
				start = now_nano();
			}
		}
	}
    printf("Client %d: %lu ns\n", targ->id, (now_nano() - start_time));

	targ->letter = cur_letter;
 	cur_letter++;

    numbers[i] = 0;

    return 0;
}

struct BAKERY *
get_number_1_svc(struct BAKERY *argp, struct svc_req *rqstp)
{
	static struct BAKERY result;
	int i = cur_id;
	int max = 0;
	
	cur_id++;
	choosing[i] = true;

	for (int j = 0; j < 32; j++)
		if (numbers[j] > max)
			max = numbers[j];

	numbers[i] = max + 1;
	choosing[i] = false;

	result.id = i;
	result.number = numbers[i];

	return &result;
}

struct BAKERY *
wait_service_1_svc(struct BAKERY *argp, struct svc_req *rqstp)
{
	static struct BAKERY  result;

	pthread_t thread;
	int i = argp->id;
	threads_results[i].id = i;
	starts[i] = now_nano();
	pthread_create(&thread, NULL, get_service, &threads_results[i]);
	threads[i] = thread;

	return &result;
}

struct BAKERY *
get_service_1_svc(struct BAKERY *argp, struct svc_req *rqstp)
{
	static struct BAKERY  result;

	pthread_join(threads[argp->id], NULL);
	printf("Client %d: %lu ns\n", argp->id, (now_nano() - starts[argp->id]));
	result.id = argp->id;
	result.letter = threads_results[argp->id].letter;

	return &result;
}

